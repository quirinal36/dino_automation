# 탐구보고서

## 컴퓨터 비전 기술을 활용한 Chrome Dino 게임 자동화 시스템 개발

---

| 항목 | 내용 |
|------|------|
| **탐구 주제** | 컴퓨터 비전과 이미지 처리 기술을 활용한 게임 자동화 시스템 개발 |
| **탐구 기간** | 2026년 1월 |
| **탐구 분야** | 컴퓨터 공학, 인공지능, 이미지 처리 |

---

## 목차

1. [탐구 동기 및 목적](#1-탐구-동기-및-목적)
2. [이론적 배경](#2-이론적-배경)
   - 2.1 컴퓨터 비전의 개념
   - 2.2 이미지 처리 기초
   - 2.3 게임 자동화의 원리
3. [탐구 방법 및 과정](#3-탐구-방법-및-과정)
   - 3.1 개발 환경 구성
   - 3.2 시스템 설계
   - 3.3 핵심 알고리즘 구현
4. [탐구 결과](#4-탐구-결과)
   - 4.1 완성된 시스템 구조
   - 4.2 장애물 감지 알고리즘
   - 4.3 동적 속도 조정 시스템
   - 4.4 실행 결과 및 성능
5. [결론 및 고찰](#5-결론-및-고찰)
   - 5.1 탐구 결과 요약
   - 5.2 배운 점 및 느낀 점
   - 5.3 한계점 및 개선 방향
6. [참고 문헌](#6-참고-문헌)
7. [부록](#7-부록)

---

## 1. 탐구 동기 및 목적

### 1.1 탐구 동기

Chrome 브라우저에서 인터넷 연결이 끊어지면 나타나는 공룡 게임(chrome://dino)은 단순하지만 중독성 있는 게임이다. 이 게임을 플레이하면서 "컴퓨터가 이 게임을 대신 플레이할 수 있을까?"라는 의문이 들었다.

이 질문에서 출발하여, 컴퓨터가 화면을 '보고' 판단하여 행동하는 과정을 직접 구현해보고자 하였다. 이는 자율주행 자동차, 산업용 로봇의 불량품 검사 등 실생활에서 활용되는 컴퓨터 비전 기술의 기초 원리를 학습할 수 있는 좋은 기회라고 생각했다.

### 1.2 탐구 목적

1. **컴퓨터 비전의 기초 원리 이해**: 컴퓨터가 이미지를 인식하고 처리하는 방법을 실습을 통해 학습한다.
2. **알고리즘 설계 능력 향상**: 문제를 분석하고 해결책을 알고리즘으로 설계하는 논리적 사고력을 기른다.
3. **프로그래밍 역량 강화**: Python과 OpenCV 라이브러리를 활용한 실제 프로젝트 개발 경험을 쌓는다.
4. **적응형 시스템 구현**: 변화하는 환경(게임 속도 증가, 다크 모드 전환)에 대응하는 동적 시스템을 설계한다.

---

## 2. 이론적 배경

### 2.1 컴퓨터 비전의 개념

**컴퓨터 비전(Computer Vision)**은 컴퓨터가 디지털 이미지나 비디오에서 의미 있는 정보를 추출하고 이해하는 기술이다. 인간의 시각 시스템을 모방하여 기계가 '보고' '이해'할 수 있도록 하는 인공지능의 한 분야이다.

컴퓨터 비전의 주요 응용 분야:
- 자율주행 자동차의 도로 인식
- 의료 영상 분석
- 얼굴 인식 및 보안 시스템
- 산업용 품질 검사
- 게임 및 엔터테인먼트

### 2.2 이미지 처리 기초

#### 2.2.1 디지털 이미지의 구조

디지털 이미지는 **픽셀(Pixel)**이라는 작은 점들의 집합으로 구성된다. 각 픽셀은 색상 정보를 담고 있으며, 일반적으로 RGB(빨강, 초록, 파랑) 세 가지 색상 채널의 조합으로 표현된다.

```
이미지 = 픽셀들의 2차원 배열
픽셀 = (R, G, B) 값 (각각 0~255)

예: 흰색 = (255, 255, 255)
    검정색 = (0, 0, 0)
    빨간색 = (255, 0, 0)
```

#### 2.2.2 그레이스케일 변환

컬러 이미지를 흑백 이미지로 변환하는 과정이다. RGB 세 채널을 하나의 밝기 값으로 통합하여 연산량을 줄이고 분석을 단순화한다.

**변환 공식:**
```
Gray = 0.299 × R + 0.587 × G + 0.114 × B
```

이 가중치는 인간의 눈이 녹색에 가장 민감하고 파란색에 가장 둔감하다는 시각적 특성을 반영한 것이다.

#### 2.2.3 관심 영역(ROI: Region of Interest)

전체 이미지에서 분석이 필요한 특정 영역만 추출하여 처리하는 기법이다. 불필요한 영역을 제외함으로써 처리 속도를 높이고 정확도를 향상시킨다.

```
전체 화면 (1920 × 1080 픽셀)
    ↓ ROI 추출
관심 영역 (72 × 46 픽셀) → 연산량 99.8% 감소
```

### 2.3 게임 자동화의 원리

게임 자동화 시스템의 기본 동작 흐름:

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  화면 캡처  │ →  │ 이미지 분석 │ →  │  판단 결정  │ →  │  입력 실행  │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
      ↑                                                        │
      └────────────────────────────────────────────────────────┘
                           (반복 루프)
```

이 과정은 인간이 게임을 플레이하는 방식과 유사하다:
1. **인지(Perception)**: 화면을 본다 → 화면 캡처
2. **분석(Analysis)**: 장애물을 인식한다 → 이미지 처리
3. **판단(Decision)**: 점프 여부를 결정한다 → 알고리즘
4. **행동(Action)**: 키보드를 누른다 → 입력 자동화

---

## 3. 탐구 방법 및 과정

### 3.1 개발 환경 구성

#### 3.1.1 사용 기술 스택

| 구분 | 기술 | 용도 |
|------|------|------|
| 프로그래밍 언어 | Python 3.7+ | 전체 시스템 개발 |
| 컴퓨터 비전 | OpenCV | 이미지 처리 및 분석 |
| 화면 캡처 | Pillow (PIL) | 스크린샷 획득 |
| 수치 연산 | NumPy | 배열 연산 및 통계 계산 |
| 입력 자동화 | PyAutoGUI | 키보드 입력 시뮬레이션 |
| 데이터 저장 | JSON | 설정 및 결과 저장 |

#### 3.1.2 라이브러리 설치

```bash
pip install opencv-python numpy pyautogui Pillow
```

### 3.2 시스템 설계

#### 3.2.1 전체 시스템 아키텍처

시스템은 두 개의 주요 프로그램으로 구성된다:

```
┌─────────────────────────────────────────────────────────────────┐
│                    Chrome Dino Automation                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌──────────────────┐           ┌──────────────────────────┐   │
│   │   calibrate.py   │           │        main.py           │   │
│   │  (캘리브레이션)  │           │     (게임 자동화)        │   │
│   ├──────────────────┤           ├──────────────────────────┤   │
│   │ - 화면 캡처      │           │ - ROI 설정 로드          │   │
│   │ - ROI 영역 선택  │    →      │ - 장애물 감지            │   │
│   │ - 좌표 저장      │  JSON     │ - 자동 점프              │   │
│   └──────────────────┘  파일     │ - 속도 조정              │   │
│                                  │ - 다크모드 대응          │   │
│                                  └──────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.2.2 클래스 설계

**1. ROICalibrator 클래스 (calibrate.py)**
- 화면을 캡처하고 사용자가 마우스로 관심 영역을 지정할 수 있게 함
- 선택된 좌표를 JSON 파일로 저장

**2. SpeedController 클래스 (main.py)**
- 게임 진행 시간에 따라 동적으로 파라미터를 조정
- 게임 속도 증가에 대응하는 적응형 시스템

**3. DinoGameBot 클래스 (main.py)**
- 장애물 감지 및 점프 실행
- 다크 모드 자동 전환
- 디버그 정보 저장

### 3.3 핵심 알고리즘 구현

#### 3.3.1 장애물 감지 알고리즘

**원리**: 게임 화면에서 장애물(선인장, 새)은 배경과 다른 색상을 가진다. 라이트 모드에서 배경은 밝고 장애물은 어둡다. 이 밝기 차이를 이용하여 장애물을 감지한다.

**구현 과정**:

```python
def is_obstacle_detected(self, roi_img, threshold=128, ratio_threshold=0.05):
    # 1단계: 그레이스케일 변환
    gray = cv2.cvtColor(roi_img, cv2.COLOR_RGB2GRAY)

    # 2단계: 밝기 분석
    avg_brightness = np.mean(gray)  # 평균 밝기
    dark_pixels = np.sum(gray < threshold)  # 어두운 픽셀 개수
    total_pixels = gray.size  # 전체 픽셀 개수
    dark_ratio = dark_pixels / total_pixels  # 어두운 픽셀 비율

    # 3단계: 장애물 판정
    if self.dark_mode:
        # 다크 모드: 밝은 픽셀이 장애물
        light_ratio = 1 - dark_ratio
        is_obstacle = light_ratio > ratio_threshold
    else:
        # 라이트 모드: 어두운 픽셀이 장애물
        is_obstacle = dark_ratio > ratio_threshold

    return is_obstacle, avg_brightness, dark_ratio
```

**알고리즘 흐름도**:

```
┌─────────────┐
│ ROI 이미지  │
│   입력      │
└──────┬──────┘
       ↓
┌─────────────┐
│ 그레이스케일│
│   변환      │
└──────┬──────┘
       ↓
┌─────────────┐
│ 픽셀 밝기   │
│   분석      │
└──────┬──────┘
       ↓
┌─────────────┐     예    ┌─────────────┐
│ 어두운 픽셀 │──────────→│  장애물!    │
│ > 임계값?   │           │  점프 실행  │
└──────┬──────┘           └─────────────┘
       │ 아니오
       ↓
┌─────────────┐
│ 장애물 없음 │
│  대기       │
└─────────────┘
```

#### 3.3.2 동적 속도 조정 시스템

Chrome Dino 게임은 시간이 지남에 따라 속도가 점점 빨라진다. 이에 대응하기 위해 로그 함수 기반의 동적 조정 시스템을 구현했다.

**속도 배율 공식**:
```python
progress = elapsed_time / TIME_TO_MAX  # 0.0 ~ 1.0
speed_factor = 1.0 + 1.17 × (log(1 + 2 × progress) / log(3))
```

이 공식은 다음과 같은 특성을 가진다:
- 초반에 급격히 증가하고 후반에 완만해지는 로그 곡선
- 시작 시 1.0배, 180초 후 최대 2.17배

**동적 파라미터 변화**:

| 파라미터 | 시작 (0초) | 최대 (180초) | 계산 방식 |
|----------|-----------|-------------|-----------|
| 속도 배율 | 1.00x | 2.17x | 로그 곡선 |
| 화면 체크 간격 | 50ms | 23ms | 기본값 / 속도배율 |
| 점프 쿨다운 | 300ms | 138ms | 기본값 / 속도배율 |
| 감지 임계값 | 5% | 3% | 선형 감소 |

#### 3.3.3 다크 모드 자동 전환

게임이 700점에 도달하면 화면이 다크 모드로 전환된다. 이를 자동으로 감지하고 대응하는 로직을 구현했다.

```python
def check_dark_mode(self, roi_img):
    gray = cv2.cvtColor(roi_img, cv2.COLOR_RGB2GRAY)
    dark_ratio = np.sum(gray < 128) / gray.size

    if dark_ratio >= 0.95:  # 95% 이상 어두우면
        self.dark_mode = True
    elif dark_ratio <= 0.05:  # 5% 이하로 어두우면
        self.dark_mode = False
```

---

## 4. 탐구 결과

### 4.1 완성된 시스템 구조

최종 완성된 프로젝트의 파일 구조:

```
dino_automation/
├── calibrate.py          # ROI 캘리브레이션 도구
├── main.py               # 게임 자동화 메인 프로그램
├── roi_config.json       # ROI 설정 파일
├── report.json           # 플레이 기록
├── requirements.txt      # 의존성 패키지 목록
├── README.md             # 프로젝트 문서
├── PRD.md                # 제품 요구사항 문서
└── debug_captures/       # 디버그 이미지 저장 폴더
```

### 4.2 장애물 감지 알고리즘 성능

구현된 알고리즘의 특징:

1. **효율성**: ROI 기법을 사용하여 전체 화면(약 200만 픽셀) 대신 작은 영역(약 3,300 픽셀)만 분석
   - 처리량 감소: 99.8%
   - 실시간 처리 가능 (50ms 이하)

2. **적응성**: 라이트/다크 모드 자동 전환으로 환경 변화에 대응

3. **정확성**: 픽셀 비율 기반 감지로 노이즈에 강건함

### 4.3 동적 속도 조정 시스템

SpeedController의 동작:

```
시간(초)    속도배율    체크간격    쿨다운     임계값
   0         1.00x       50ms      300ms      5.0%
  30         1.35x       37ms      222ms      4.4%
  60         1.58x       32ms      190ms      3.9%
  90         1.75x       29ms      171ms      3.5%
 120         1.89x       26ms      159ms      3.3%
 150         2.00x       25ms      150ms      3.1%
 180         2.17x       23ms      138ms      3.0%
```

### 4.4 실행 결과 및 성능

**콘솔 출력 예시**:

```
Chrome Dino Game Bot을 시작합니다...

ROI 설정 로드 완료:
  좌표: (343, 252) ~ (415, 288)
  크기: 72 x 46

============================================================
Chrome Dino Game Automation 시작
============================================================
동적 속도 조정: 활성화
  - 초기 체크 간격: 50ms
  - 초기 쿨다운: 300ms
  - 최대 속도 배율: 2.17x (약 180초 후)

점프! (총 1번)
  - 평균 밝기: 245.3, 어두운 픽셀 비율: 8.2%

[속도] 30초 | 1.35x | 모드: 라이트 | 체크: 37ms

[모드 전환] 다크 모드 감지 → 밝은 픽셀 감지로 전환

점프! (총 48번)
  - 평균 밝기: 45.2, 밝은 픽셀 비율: 7.5%

--- 종료 ---
총 플레이 시간: 125.3초
총 점프 횟수: 48번
```

---

## 5. 결론 및 고찰

### 5.1 탐구 결과 요약

본 탐구를 통해 컴퓨터 비전 기술을 활용한 Chrome Dino 게임 자동화 시스템을 성공적으로 개발하였다.

**주요 성과**:

1. **장애물 감지 시스템**: 픽셀 밝기 분석 기반의 효율적인 장애물 감지 알고리즘 구현
2. **적응형 속도 조정**: 게임 속도 증가에 대응하는 로그 함수 기반 동적 파라미터 시스템 개발
3. **환경 변화 대응**: 라이트/다크 모드 자동 전환 기능 구현
4. **실용적 도구 개발**: 사용자 친화적인 ROI 캘리브레이션 도구 제작

### 5.2 배운 점 및 느낀 점

#### 5.2.1 기술적 학습

1. **이미지 처리의 기초**: 디지털 이미지의 구조(픽셀, 채널, 해상도)와 그레이스케일 변환의 원리를 이해하게 되었다.

2. **알고리즘 설계**: 문제를 작은 단위로 분해하고 각각을 해결하는 "분할 정복" 사고방식을 익혔다.

3. **적응형 시스템**: 고정된 값이 아닌 상황에 따라 변하는 동적 시스템의 중요성을 깨달았다.

4. **디버깅 기법**: 디버그 이미지 저장을 통해 문제를 시각적으로 분석하고 해결하는 방법을 배웠다.

#### 5.2.2 느낀 점

- 단순해 보이는 게임도 자동화하려면 많은 고려사항(속도 변화, 모드 전환, 다양한 장애물)이 있다는 것을 알게 되었다.
- 컴퓨터 비전 기술이 자율주행, 의료 영상 분석 등 다양한 분야에서 어떻게 활용되는지 실감할 수 있었다.
- 프로그래밍은 단순히 코드를 작성하는 것이 아니라 문제를 분석하고 해결책을 설계하는 과정이라는 것을 깨달았다.

### 5.3 한계점 및 개선 방향

#### 5.3.1 현재 시스템의 한계

1. **새(bird) 장애물 대응 미흡**: 높이가 다른 새 장애물에 대한 웅크리기 기능 미구현
2. **해상도 의존성**: 특정 해상도에서만 정확하게 동작
3. **단일 ROI 한계**: 하나의 관심 영역만 사용하여 다양한 장애물 패턴 대응에 한계

#### 5.3.2 향후 개선 방향

| 우선순위 | 개선 사항 | 설명 |
|----------|----------|------|
| P1 | 새 장애물 대응 | 높이별 다중 ROI 설정 및 웅크리기 기능 추가 |
| P2 | 머신러닝 도입 | 딥러닝 기반 장애물 인식으로 정확도 향상 |
| P2 | 점수 인식 | OCR 기술로 실시간 점수 추적 |
| P3 | GUI 개발 | 사용자 친화적인 그래픽 인터페이스 추가 |

---

## 6. 참고 문헌

1. **OpenCV 공식 문서** - https://docs.opencv.org/
2. **Python 공식 문서** - https://docs.python.org/
3. **NumPy 사용자 가이드** - https://numpy.org/doc/
4. **컴퓨터 비전 기초** - Szeliski, Richard. "Computer Vision: Algorithms and Applications"
5. **Chrome Dino Game 분석** - https://chromedino.com/

---

## 7. 부록

### 부록 A: 주요 소스 코드

#### A.1 장애물 감지 함수

```python
def is_obstacle_detected(self, roi_img, threshold=128, ratio_threshold=0.05):
    """
    ROI 이미지에서 장애물을 감지한다.

    Args:
        roi_img: ROI 영역 이미지 (RGB)
        threshold: 밝기 임계값 (0-255)
        ratio_threshold: 장애물 판정 비율 임계값

    Returns:
        tuple: (장애물_여부, 평균_밝기, 어두운_픽셀_비율)
    """
    # 그레이스케일 변환
    gray = cv2.cvtColor(roi_img, cv2.COLOR_RGB2GRAY)

    # 밝기 분석
    avg_brightness = np.mean(gray)
    dark_pixels = np.sum(gray < threshold)
    total_pixels = gray.size
    dark_ratio = dark_pixels / total_pixels

    # 모드별 장애물 감지
    if self.dark_mode:
        light_ratio = 1 - dark_ratio
        is_obstacle = light_ratio > ratio_threshold
        return is_obstacle, avg_brightness, light_ratio
    else:
        is_obstacle = dark_ratio > ratio_threshold
        return is_obstacle, avg_brightness, dark_ratio
```

#### A.2 동적 속도 계산 함수

```python
def get_speed_factor(self):
    """게임 진행 시간에 따른 속도 배율을 계산한다."""
    if self.start_time is None:
        return 1.0

    elapsed = time.time() - self.start_time
    progress = min(elapsed / self.TIME_TO_MAX, 1.0)

    # 로그 곡선으로 속도 증가 (초반 급증, 후반 완만)
    speed_factor = 1.0 + (self.MAX_SPEED_FACTOR - 1.0) * (
        math.log(1 + 2 * progress) / math.log(3)
    )

    return min(speed_factor, self.MAX_SPEED_FACTOR)
```

### 부록 B: 실험 데이터

#### B.1 플레이 기록 예시

| 세션 | 플레이 시간 | 점프 횟수 | 종료 원인 |
|------|------------|----------|----------|
| 1 | 45.2초 | 18회 | 새 장애물 충돌 |
| 2 | 125.3초 | 48회 | 사용자 종료 |
| 3 | 89.7초 | 35회 | 연속 장애물 충돌 |

#### B.2 ROI 설정 예시

```json
{
    "roi": {
        "x1": 343,
        "y1": 252,
        "x2": 415,
        "y2": 288
    },
    "width": 72,
    "height": 46
}
```

### 부록 C: 용어 정리

| 용어 | 설명 |
|------|------|
| 컴퓨터 비전 | 컴퓨터가 이미지를 이해하고 분석하는 기술 |
| ROI | Region of Interest, 관심 영역 |
| 그레이스케일 | 컬러 이미지를 흑백으로 변환한 것 |
| 픽셀 | 디지털 이미지를 구성하는 가장 작은 단위 |
| 임계값 | 판단 기준이 되는 경계값 |
| 다크 모드 | 어두운 배경의 화면 모드 |

---

**작성 완료**

이 보고서는 Chrome Dino 게임 자동화 프로젝트의 개발 과정과 결과를 정리한 탐구보고서입니다.
